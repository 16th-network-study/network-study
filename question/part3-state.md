1. Preflight 요청에 관해서 설명해주세요.
   > 박종하: Preflight 요청은 지금 보내는 요청이 CORS 정책을 위반하는지 미리 확인하기 위한 요청입니다. Preflight 요청을 보내는 이유는 볼륨이 큰 요청을 보냈을 때 CORS 정책에 막혀서 불필요한 리소스가 생기는 걸 방지하기 위해서입니다.
   > <br>
   > Preflight 요청은 OPTIONS 메소드로 전송되며 Access-Control-Request-Method, Access-Control-Request-Header, Origin이 담겨서 전송됩니다.
   > <br>
   > 그 응답으로는 204 No Content로 가능한 메소드 및 지원하면 Access-Control-Max-Age가 추가로 담겨서 옵니다.
   
   > 문진수
   > 
   > Preflight란 브라우저가 요청을 보내기 전에 미리 요청을 보낼 수 있는 상태인지 확인차 보내는 요청을 말합니다. 사용자의 요청 데이터를 보호하거나 CORS 확인 용도로 사용됩니다. 그리고 HTTP Method OPTIONS를 사용합니다.

---

2. 임의의 상태 코드를 만들어서 1000번으로 주는 것에 대해서는 어떻게 생각하시나요?

   > 문진수
   >
   > 임의의 상태 코드를 만들어서 사용할 경우 표준이 아니기 때문에 유지보수, 운영 환경에서 문제가 발생할 수 있습니다. 후임이 들어왔는데 상태코드 1000을 보면 당황할 거 같습니다. 그리고 별도의 문서로 관리해야 하기 때문에 공수가 늘어납니다.

---

3. 쿠키, 세션, 토큰의 차이에 대해서 설명해주세요.
   > 박종하: 쿠키는 키-밸류 형식의 문자열 형태로 클라이언트의 브라우저에 클라이언트에 관한 정보를 저장하는 방식입니다. 클라이언트는 서버에서 쿠키를 받은 후 이후의 요청에서 헤더에 쿠키를 담아서 보내는 식으로 작동합니다. 단점으로는 보안에 취약하고, 브라우저간 호환성이 좋지 않습니다,
   > <br>
   > 세션은 클라이언트의 정보를 서버에 저장하는 방법입니다. 세션 객체는 Session ID를 key로 하는 key-value로 이루어져 있습니다. 클라이언트 측에서 요청에 Session ID를 담아서 전송하면 서버에서는 Session ID를 비교해 인증을 처리합니다. 마찬가지로 Session ID 탈취의 위험성이 있습니다.
   > <br>
   > 토큰은 서버에 접속 시 해당 클라이언트에게 유일한 토큰을 부여하는 방식입니다. 클라이언트는 그 이후로 모든 요청 헤더에 토큰을 넣어서 보내며 쿠키와 마찬가지로 클라이언트에 저장됩니다. Statelss하면서도 필요 시 상태를 유지할 수 있는 장점이 있습니다. 단점으로는 마찬가지로 토큰을 탈취 위험성이 존재하지만 이를 유효 기간 설정으로 보완하고 있습니다.
   
   > 문진수
   >
   > 쿠키는 key-value 형태로 저장되고 서버에서 생성하여 만료 시간과 함께 클라이언트로 전송됩니다. HttpOnly 속성을 설정하여 javaScript를 통해 쿠키에 접근할 수 없게 만들어서 보안을 강화할 수 있습니다. 그리고 Secure Cookie를 사용하면 HTTPS가 아닌 HTTP 통신을 할 때 쿠키를 전송하지 않음으로써 쿠키 탈취를 막을 수 있습니다.
   >
   > 세션은 서버의 메모리에 세션 정보를 저장하는 방식입니다. 서버 메모리를 사용해야 하기 때문에 이에 따른 오버헤드가 존재하고 기본적으로는 서버간의 세션 정보는 공유되지 않기 때문에 다른 서버로 요청이 가게 되면 세션 정보를 활용할 수 없습니다. (sticky session을 사용하면 같은 서버로만 라우팅되도록 할 수는 있습니다.)
   >
   > 토큰 방식은 토큰에 데이터를 저장하고 암호화하여 사용합니다. 토큰에 데이터를 저장하고 주고 받기 때문에 서버는 무상태로 유지할 수 있습니다. JWT 토큰의 경우 Header, payload, signature로 구성됩니다. Header에는 암호화에 사용되는 알고리즘(HMAC)이 들어있고 Payload는 만료시간, 데이터 등이 들어있습니다. Signature는 Header와 Payload를 Base64로 인코딩한 것을 합쳐서 Header의 암호화 알고리즘으로 암호화한 값이 들어갑니다.

---

4. Stateful과 Stateless에 대해서 설명해주세요.
   > 박종하: Stateful은 클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존함을 의미합니다. 이전 단계에서 제공받은 데이터를 저장하고 추후 그 데이터를 바탕으로 로직을 다르게 가져갑니다. Stateful의 예시로는 TCP가 있습니다. Stateful은 서버가 다중화 되어 있는 경우에서는 모든 서버가 같은 값을 저장하고 있어야 하는 단점이 존재합니다. <br>
   > Stateless는 반대로 서버가 클라이언트의 상태를 보존하지 않습니다. 따라서 상태유지에 대한 부하가 없습니다. Stateless의 예시로는 연결 세션을 따지지 않는 HTTP 통신, UDP가 있겠습니다. 즉 동일한 연산을 해도 그 값이 변하지 않습니다.
   > <br>
   > Sticky Session은 특정 서버에 세션을 저장하는 방식입니다. 세션 쿠키를 사용하여 구현하며, 쿠키를 발급하는 주체에 따라 로드 밸런서가 주체인 duration-based, 애플리케이션이 주체인 application-controlled 두 가지로 나뉩니다.
   > <br>
   > 분산형 WAS에서도 상태를 유지할 수 있는 장점이 있지만, 확장성이 매우 떨어지고 세션을 저장한 서버가 다운되면 모든 세션정보를 잃는다는 한계점이 있습니다.
   
   > 문진수
   >
   > Stateful은 서버가 클라이언트의 상태를 서버에 유지하고 있는 것을 말합니다. 예를 들어서 유저의 로그인 정보를 서버 메모리에 저장하여 클라이언트의 요청이 오면 로그인 여부에 따라 로직을 처리할 수 있습니다.
   >
   > 이 방식의 경우 요청이 다른 서버로 가게 되면 기존 세션 정보를 사용할 수 없습니다. 이를 해결하기 위해 동일한 클라이언트는 동일한 서버로 요청이 라우팅되도록 할 수 있습니다. 이를 sticky 세션 이라고 합니다.
   >
   > 그리고 SSE와 같이 서버에서 클라이언트 정보를 가진 객체를 저장하고 필요할 때마다 클라이언트의 요청 없이 서버에서 응답을 내려줄 수도 있습니다.
   >
   > Stateless는 서버에 상태를 유지하지 않는 것을 말합니다. Token을 활용하여 Token에 데이터를 저장하고 이를 요청마다 서버에 보냄으로써 무상태 서버를 유지하면서 상태가 존재하는 것처럼 작동하게 할 수 있습니다.

---

5. Stateful하게 통신하는 경우에 대해서 예시를 설명해주세요.
   > 박종하: Stateful한 통신의 실시간 데이터 교환이 필요한 경우가 있습니다. WebSocket같이 실시간으로 데이터 교환이 필요한 경우에서는 Stateful한 통신을 사용합니다. 또한 연결을 유지하는 것이 긍정적인 경우에 대해서도 사용합니다. IOT 시스템에서도 실시간 데이터와 기존 데이터를 비교해서 서비스를 제공하는 경우가 많기 때문에 Stateful하게 통신하는 예시입니다.
   
   > 문진수
   >
   > TCP 통신은 송수신측에 송신, 수신 버퍼를 가지고 있고 수신측의 현재 남은 윈도우 사이즈를 송신측에 보냄으로써 데이터 전송량을 결정합니다. 이는 상태를 유지하고 있다고 할 수 있습니다.
   >
   > 또한 WebSocket을 사용할 경우 서버에 세션 정보를 저장하게 됩니다. 이 또한 상태를 가진 상태로 통신하는 예라고 말할 수 있습니다.

---

6. Stateless하게 통신하는 경우에 대해서 예시를 설명해주세요.
   > 박종하: Stateless하게 통신하는 예시로는 REST API가 있습니다. REST API에서는 요청을 한 쪽 또는 endpoint로 기존의 요청과는 관계없이 매번 개별적인 요청을 또는 응답을 보냅니다.
   
   > 문진수
   >
   > HTTP 프로토콜은 웹상에서 클라이언트-서버간의 통신을 할 때 사용하는 프로토콜입니다. 해당 프로토콜은 무상태로 동작합니다.

---

7. Stateless와 Connectionless의 차이는 무엇인가요?
   > 박종하: Connectionless는 비연결성이라고 하며, HTTP 요청이 끝나면 서버와 클라이언트의 연결을 유지하지 않는다는 것을 의미합니다. 반면에 Stateless는 서버가 이전 요청의 정보를 기억하지 않는다는 것을 의미합니다.
   
   > 문진수
   >
   > Stateless는 상태 유지 여부에 관한 얘기이고 Connectionless는 통신을 할 때 논리적인 연결을 수립하는지에 대한 것입니다.

---

8. SOP에 대해서 설명해주세요
   > 박종하:동일 출처 정책은 어떤 출처에서 불러온 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용하는 것을 제한하는 보안 방식입니다. 이때 동일 출처라 함은 프로토콜, 호스트, 포트가 같은 경우를 말합니다.
   
   > 문진수
   >
   > SOP란 Same Origin Policy의 약어로 하나의 출처에서 나온 데이터가 다른 출처에 접근하지 못하도록 막는 보안 정책을 말합니다. CSRF, XSS등 다른 사용자의 민감한 정보 탈취를 막는 용도로 사용되는 정책입니다.
   >
   > 여기서 Origin은 웹 브라우저에서 보안 정책을 적용할 때 사용하는 개념으로 두 URL이 같은 출처로 취급되기 위해서는 프로토콜, 호스트, 포트 번호가 모두 동일해야 합니다.

---

※ 응답 예시

> 네트워크 스터디 공유부탁드립니다.

> 다음 스터디는 자바네요.
