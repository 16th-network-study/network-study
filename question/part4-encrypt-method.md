1. CORS에 대해서 설명해주세요.

   > 문진수
   >
   > CORS는 교차 출처 리소스 공유를 말하며 브라우저가 자신의 출처가 아닌 다른 출처로부터 자원을 로딩할 수 있도록 허가하는 보안 정책을 말합니다. Preflight 요청을 통해 CORS 확인을 할 수 있습니다.

---
2. HTTP와 HTTPS 프로토콜의 차이는 무엇인가요?

> 문진수
>
> HTTP는 데이터를 암호화하지 않고 평문으로 전송하기 때문에 네트워크 상에서 중간에 데이터를 탈취하거나 변조당할 위험이 있습니다. 반면 HTTPS는 TLS 프로토콜을 기반으로 데이터를 암호화하여 안전한 통신을 제공합니다. TLS는 클라이언트와 서버가 통신을 시작할 때 핸드쉐이크 과정을 통해 대칭키를 안전하게 공유합니다. 이때 클라이언트는 서버의 공개키(CA 인증서)를 이용해 생성한 세션키를 암호화하여 전송하고 서버는 자신의 비밀키로 이를 복호화하여 세션키를 획득합니다. 이후에는 세션키를 사용해 양쪽 모두 암호화된 데이터를 주고받게 됩니다.

---
3. 대칭키와 공개키의 차이는 무엇인가요?

> 문진수
>
> 대칭키 암호는 암호화, 복호화에 동일한 키를 사용하는 알고리즘입니다. 이 방식에서는 송/수신자가 동일한 키를 공유해야 합니다. 일반적으로 공개키 암호화 방식에 비해 속도가 빠릅니다. 공개키 방식은 암호화, 복호화에 서로 다른 키를 사용합니다.  암/복호화에 복잡한 수학 연산이 사용되기 때문에 대칭키 암호에 비해 속도가 느립니다. RSA, ElGamal, ECC 알고리즘 등이 있고 대칭키를 공유하기 위해 공개키 암호화 방식이 많이 쓰입니다.

---
4. 알고 있는 암호화 방식 중 하나만 설명해주세요.
> 강진주
>
> - 대표적으로 많이 알려진 RSA 공개키 암호화
>    - RSA 공개키 암호화 방식은 암호화를 위한 공개키와 암호화문을 복호화하기 위한 개인키, 한 쌍으로 관리된다.
>    - 공개키와 개인키는 서로 다른 키 값을 가져서 비대칭키 암호화 방식이라고도 불린다.
>    - 한 쌍의 공개키와 개인키를 생성하기 위해서 매우 큰 소수 값과 모듈로 연산을 통해 소인수분해하기 어려운 값으로 만들어 암호화한다.
> - RSA 방식에 대해서 단점: 큰 소수 값 계산에 소모되는 리소스가 크다, 여러 공격에 취약하다.
>    - RSA의 취약점이, 기존에 RSA 방식을 사용하던 TLS 1.2에도 똑같이 취약점으로 작용함.
>        - 컴퓨터 계산이 발전함에 따라 TLS 1.2  에서 사용하던 인증서 키 일부가 뚫리는 현상 발생
>    - 실제로 TLS 1.2 → 1.3 버전 업그레이드에서 보안이 강화되었다는 특징이 대표적으로 알려져 있는데, 조금 더 세부적으로 들어가면, RSA 방식과 같이 취약한 방식이 1.3 에서 더 좋은 알고리즘으로 대체되었기 때문이다.

> 문진수
>
> HTTPS 통신에 사용되는 TLS는 평문으로 전송되던 HTTP에 보안 기능을 추가해주는 프로토콜입니다. 송/수진자 간에 세션키를 공유하기 위해 공개키 암호화 방식이 사용됩니다. 서버는 자신의 인증서를 클라이언트에 보내고 클라이언트는 CA에서 서버의 인증서를 검증하고 서버와 공유할 대칭키를 생성합니다. 생성한 대칭키를 인증서에 있는 서버의 공개키로 암호화하여 서버에 보내게 되고 서버는 이를 자신의 비밀키로 복호화합니다. 이렇게 공유된 세션키를 가지고 이후 평문을 암호화하여 전송함으로서 네트워크 상에서 안전하게 통신할 수 있게 됩니다.

---
5. BASE64에 대해서 설명해주세요.
> 강진주
>
> - BASE64는 자료에 대해서 6bit 씩 binary 데이터를 끊어서, 매칭되는 아스키 문자로 변경하는 인코딩 방식이다.
> - 만약, 데이터가 6bit로 깔끔하게 떨어지지 않는 경우에는 패딩을 추가한다.
> - 위와 같은 동작적인 특징으로 생기는 BASE64의 단점
>    - 인코딩으로 변환하는 과정에서 데이터 크기가 약 33% 증가한다.
>    - 이런 단점이 있지만 이를 상쇄하는 장점이 있기 때문에 사용한다.
>        1. 운영 체제나 언어 체계가 다양한 경우에도 인코딩 호환성이 좋다. 아스키 문자 세트만 사용하므로 환경에 대한 제약 사항 없이 인코딩해서 보낼 수 있다.
>        2. 안정성이 높다. binary 데이터를 텍스트 환경에서 손실 없이 안전하게 전송할 수 있기 때문이다. 전송 과정 중에 손실 발생하지 않고, 암호화 된 값이나 해시 값도 모두 이진 데이터를 거쳐서 BASE64로 인코딩 하면 안전하게 보낼 수 있다.  ex. JWT 토큰에서 사용) 

> 문진수
>
> BASE64는 데이터를 6bit씩 끊어서 특정한 문자로 매핑하여 문자열로 변환하여 저장하는 방식을 말합니다. 6bit로 깔끔하게 잘리지 않을 수도 있는데 이때는 = 문자열을 패딩해서 저장하게 됩니다. 그리고 텍스트 기반으로 데이터를 전송할 때 다양한 미디어 타입을 지원하기 위해 불필요하게 데이터를 나눠 보낼 필요가 없습니다. 또한 어떤 인코딩 방식을 사용하던지 BASE64 인코딩 테이블 내에서 사용되는 모든 문자는 컴퓨터를 사용할 때 반드시 존재하는 문자로만 구성되기 때문에 호환성이 좋습니다.

---
6. REST API에 대해서 설명해주세요.
> 강진주
>
> - REST API
>    - 네트워크 상에서 고유한 리소스를 명확하게 식별하고, HTTP 프로토콜을 통해 리소스의 상태 정보나 관련된 동작을 주고 받는 API
> - REST API 가 RESTful 하게 동작하도록 만드는 제약 조건 6가지가 있는데, 그 중에서 중요한 특징
>    - Stateless (무상태성)
>        - 요청은 독립적이며, 서버는 클라이언트의 이전 요청 상태를 저장하지 않는다.
>        - 그렇기 때문에, 요청 시 **모든** 인증 정보나 데이터를 함께 전송해야 한다.
>    - Cacheable (캐싱 가능)
>        - HTTP `GET` 메서드에 대해, 캐싱 가능 여부를 명시해서 보내야 한다.
>        - 클라이언트가 이를 보고 캐싱할 수 있으며, 캐싱된 데이터가 유효한지를 판단하는 헤더등을 추가로 보내어 캐시 변경에 대한 정보를 보낼 수 있다.
>    - Uniform-Interface (일관된 인터페이스)
>        - 리소스에 접근하는 방법이 일관적이어야 한다.
>        - 모든 리소스는 고유한 url로 접근이 가능해야 한다.
> - REST API URL 설계 규칙
>    - 리소스의 명확한 식별을 위해 명사형으로 리소스를 표현하고, HTTP Method (동사)로 동작을 표현한다.
>    - URL에 여러 개의 리소스 표현이 필요하다면, 계층 구조를 통해 이를 표현해야 한다. (상위 계층에서 하위 계층으로 slash를 통한 구분)
>    - 소문자로 작성해야 하며, 단어를 구분할 때 언더바(_) 대신 하이픈(-)을 사용해서 표현한다.


---
7. PUT과 PATCH의 차이는 무엇인가요?
> 강진주
>
> - 기본적으로 `PUT` 과 `PATCH` 메서드 모두, 리소스를 수정할 때 사용한다. 그러나 기능과 특징에 대해 차이가 있다.
> - `PUT`은 전체 리소스를 수정하는 메서드여서, 요청을 보낼 때 리소스 전 범위를 보내야한다.
> - `PATCH`는 일부 리소스 수정이라서 수정할 부분만 보내도 된다. 대신, 서버에서 변경된 필드를 찾는 작업이 추가적으로 필요하다.
> - 멱등성 (문서 상의 정의 차이)
>    - RFC 문서 상으로는 PUT과 PATCH 비교에서, PUT은 전체 리소스를 완전히 대체하기 때문에 멱등성이 보장되고, PATCH는 멱등성 보장을 하지 못한다고 되어있다.
>    - (물론 PATCH 도 멱등성 보장이 대체적으로 되나, 서버의 구현이나 서버 환경에 따라 달라질 여지가 조금이라도 있어서 문서 상으로는 보장하지 못하는 것 같다.)
> - `PUT` 과 `PATCH`를 각각 어느 상황에서 사용해야 하는지 (API 설계와 특징에 따라 달라진다)
>    - 수정할 데이터의 양을 고려했을 때, PATCH에 넣을 데이터가 PUT과 비슷하거나 크다면 PUT을 사용하기를 권장 (by RFC 문서)
>    - 리소스 전체를 명확하게 덮어써서 정확한 상태를 유지하는게 필요하다면 PUT 사용
>    - 그러나 리소스의 정보 수정해야 하는 상황에서, 대규모 업데이트가 일어나면 네트워크 처리 속도를 고려하여 전체 리소스를 보내지 않고 일부만 보내는 PATCH 사용
>    - 어떤 필드에서 수정이 일어났는지 변경 사항을 추적해야 하는 상황
>        - 변경점 추적이 필요하다? `PATCH` (로그 기록, 이력을 저장하는게 핵심인 경우)
>        - 그렇지 않을 경우? `PUT`

---
8. 주소창에 www.github.com을 치면 어떻게 동작하나요?
> 강진주
>
> 1. DNS 조회 : github의 IP 주소를 찾기 위해 DNS 조회를 수행할 것이다. 만약, 캐싱된 DNS 정보가 있으면 해당 정보를 통해 IP 주소를 받을 수 있다. 해당 캐싱은 다양한 계층에서 일어나는데 (브라우저 캐시, 로컬 OS 의 캐시, ISP의 DNS 캐시 등 순차적으로 조회할 수 있다.)   
>    → 만약, 캐시 미스가 일어날 경우 root DNS 까지 타고 갈 수도 있는데 일반적으로 사람들이 자주 사용하는 대규모 서비스는 중간 단계에서 캐싱이 되어있을 가능성이 크다.
>
> 2. 이렇게 응답받은 IP 주소가 실제 서버의 IP 주소일 수도 있고, 아닐 수도 있다. 보통 글로벌 서비스는 CDN이나 글로벌 로드 밸런서를 통해 요청한 사용자의 지리적인 위치, 네트워크 혼잡도, 서버 상태 등을 총체적으로 고려해서 최적의 서버를 연결해준다.
> 3. 그 다음에는 연결 수립을 위한 동작이 일어난다. TCP 3-way-handshake 등..
> 
> → DNS의 계층 구조나, CDN 관련된 설명은 네트워크 스터디 정리에 자세하게 나와있으므로 참조 부탁합니당

> 문진수
>
> 먼저 브라우저는 도메인 이름 www.naver.com을 IP 주소로 변환하기 위해 DNS 조회를 시도합니다. 이때 브라우저 캐시 → OS 캐시 → 로컬 DNS 서버(ISP 등) 순으로 캐시를 확인하며 없다면 실제 DNS 서버에 요청해 IP를 받아옵니다. IP 주소를 얻으면 브라우저는 해당 IP의 443 포트를 대상으로 TCP 연결을 시도합니다. 이 과정에서 3-way 핸드셰이크(SYN → SYN-ACK → ACK)를 통해 연결이 수립됩니다. TCP 연결이 완료되면 TLS 핸드셰이크를 통해 보안 연결이 설정되고 이후 요청이 서버로 전송됩니다. 보통 네이버 같은 대형 서비스는 리버스 프록시 서버를 앞단에 두고 있고 이 프록시들 또한 여러대 존재합니다. 서버는 클라이언트의 요청에 따라 HTML, CSS, JS 등의 리소스를 응답으로 보내며 브라우저는 이를 렌더링해 웹 페이지를 구성합니다.

---
