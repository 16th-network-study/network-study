1. 로드밸런서에 대해서 설명해주세요.
> 백명규
> 
> - 로드밸런서는 WAS나 웹 서버 앞에 세워두어 트래픽을 여러 서버에 골고루 분산하여 한 서버에 과도하게 트래픽이 몰리는 걸 방지하는 용도로 사용이 됩니다.
>  애플리케이션 계층에서 특정 임의의 조건으로 부하를 분산하는 L7, 혹은 IP 기준으로 전송 계층에서 사용되는 L4 등이 있습니다.
> - 로드 밸런서 알고리즘, 라운드 로빈, 가중치 라운드 로빈, IP 해시 등의 분배 알고리즘 등이 있고 이 때 조심할 건 세션 등과 관련이 있는 경우에는\
> 특정 서버에 대해 연결이 지속적으로 관리가 될 수 있게 만들어야 합니다.

> 문진수
> 
> 로드밸런서란 트래픽을 여러 서버에 골고루 분산시켜주는 서비스입니다. 네트워크, 전송 계층 정보를 기반으로 트래픽을 분산하는 L4 로드밸런서와 HTTP 헤더, 쿠키와 같은 클라이언트 요청을 기반으로 부하를 분산해주는 L7 로드밸런서가 존재합니다. L7 로드밸런서의 경우 헤더의 정보를 바탕으로 더 세밀한 로드밸런싱이 가능합니다. 로드밸런싱 알고리즘으로는 라운드로빈, 가중치 라운드로빈, 최소 연결 방식, IP 해싱 방식 등 여러 방식이 존재합니다.


---
2. WebSocket에 대해서 설명해주세요.

> 백명규
> 
> WebSocket은 서버와 클라이언트 사이의 연결을 유지하여 서로 요청을 보낼 수 있게 해줍니다.
> HTTP 통신에서는 클라이언트는 요청을 보내고 서버는 응답을 내리는 역할을 하며,
> 서버는 클라이언트의 요청이 없을 때 변경 사항에 대해서 클라이언트에게 알려줄 방법이 없었습니다.
> 그래서 polling의 형태로 클라이언트 측에서 특정 초마다 요청을 보내야 했는데 이는 변경이 자주 일어나는 경우는 모르겠으나 변경이 자주 일어나지 않는 경우에 대해서는 서버에 큰 부하를 줄 수 있습니다.
> 이런 경우에는 WebSocket으로 연결을 변경하여 서버 측에서 변경이 있을 때마다 해당 이벤트마다 구독자들에게 메시지를 보낼 수 있는 형태로 변경할 수 있습니다.

> 문진수
> 
> WebSocket이란 단일 TCP 연결에서 양방향 통신을 제공하는 프로토콜입니다. HTTP 프로토콜 위에서 동작하며 HTTP Upgrade 헤더를 통해서 WebSocket 프로토콜로 스위치됩니다. WebSocket은 HTTP 폴링과 같은 반이중 통신보다 낮은 오버헤드로 클라이언트와 서버간 실시간 데이터 통신이 가능하고 HTTP 요청 없이도 응답을 줄 수 있습니다.

---
3. Blocking I/O와 Non-Blocking I/O의 차이는 무엇인가요?

> 백명규
> 
> - Blocking I/O와 Non-Blocking I/O의 차이는 I/O 작업 처리 방식에 있습니다.
> Blocking I/O에서는 특정한 작업이 요청되면 I/O 작업을 하는 동안 해당 요청을 받은 쓰레드 또한 작업이 끝날 때까지 계속해서 대기를 한다.
> 이 때, 요청을 끝내지 못해 뒤의 요청을 처리하기 위해 추가적으로 쓰레드를 생성하거나 한다면 요청이 크게 쌓였을 때 문제가 크게 생긴다.
> - Non-Blocking I/O는 I/O 작업을 처리하는 동안 요청이 끝날 때까지 대기하지 않고 작업이 끝나면 특정한 event를 받아서 처리할 수 있게 만드는 방식으로 하여 지속적으로 요청을 보내 확인하거나 하는 방법입니다.
> -> Java NIO라이브러리로 만들어지고 Webflux나 Netty 등이 Non-blocking I/O로 이루어짐.

> 문진수
> 
> Blocking I/O는 애플리케이션이 커널에 I/O 요청을 하면 커널이 해당 작업을 완료할 때까지 해당 스레드를 블로킹 상태로 만드는 방식을 말합니다. 이 동안 컨텍스트 스위치가 발생할 수도 있고 해당 스레드는 다른 작업을 할 수 없습니다. Non-Blocking I/O의 경우 fd에 read/write 시스템 콜을 호출하는 값을 읽을(쓸) 수 있는지 여부에 상관없이 바로 값을 반환하게 됩니다. 이는 fd에 O_NONBLOCK 플레그를 세팅함으로써 가능해집니다. 연산이 아예 불가능한 경우(버퍼가 가득찼는데 쓰거나 읽을 값이 없는데 읽거나) error를 반환, 부분적 성공(일부만 쓰거나 읽는), 그리고 성공적으로 연산을 수행되는 경우가 존재합니다.
> 
> *기본적으로 Non-Blocking I/O Polling 방식은 bad practice라는건 당연함. 베스트는 fd를 커널 epoll 인스턴스에 등록해놓고 값이 들어오면 notify를 스레드에 주는 방식임.

---
4. CDN 서버에 대해서 설명해주세요.
> 백명규
> 
> CDN 서버는 콘텐츠 전송 서버는 글로벌 서비스에서 주로 파일 등을 저장하고 받는 용도로 사용이 됩니다.
> 해외에 있는 컨텐츠의 경우에는 중간에 경유되는 네트워크가 많기 때문에 상대적으로 네트워크 지연이 크게 발생을 합니다.
> 그런 경우에는 여러 지역 별로 컨텐츠를 올려두는 CDN 서버를 만들어서 컨텐츠를 올려놓고 캐싱해두면 원본 서버로 직접 들어가지 않고도 컨텐츠를 빠르게 주고 받을 수 있습니다.
> 또한 원본 콘텐츠 서버의 부하도 줄일 수 있습니다.

> 문진수
> 
> CDN은 데이터 사용량이 많은 애플리케이션에서 웹 페이지 로드 속도를 높이기 위해 사용되는 상호 연결된 서버입니다. 사용자가 웹 페이지를 접속할 때마다 해당 웹 사이트의 서버에 요청을 보내고 응답을 받는데 지리상으로 먼 경우 대용량 데이터(동영상, 이미지)의 경우 로드 속도가 지연됩니다. 이를 해결하기 위해 지리적으로 분산하여 이러한 데이터를 캐싱해두게 되는데 이를 CDN 이라고 합니다. 그리고 원래 서버로 요청이 먼저 가는게 아니라 CDN을 프록시로 거쳐서 가기 때문에 보안상으로 더 안전합니다.

---
5. 인터넷에서는 어떻게 서로 다른 네트워크에 존재하는 프로세스 사이에서 데이터 통신이 가능할까요?

> 문진수
>
> 인터넷에서 통신하는 각 프로세스는 특정 호스트의 IP 주소와 포트 번호를 통해 유일하게 식별됩니다. IP 주소는 호스트를 나타내고 포트 번호는 호스트 내의 특정 프로세스를 식별하게 됩니다. 예를 들어 TCP 통신의 경우 송신 측은 상대방의 IP 주소와 포트 번호를 이용해 TCP 연결을 시도합니다. 이때 송신 측은 먼저 SYN 패킷을 전송하고 이 패킷은 여러 라우터를 거쳐 수신 측 호스트에 도달합니다. 수신 측은 이를 수신한 뒤 SYN-ACK 패킷을 송신 측으로 다시 보내며 마지막으로 송신 측이 ACK 패킷을 보내면 3-way handshake가 완료되어 논리적인 연결이 성립됩니다. 이후 해당 TCP 소켓을 통해 서로 다른 네트워크에 위치한 두 프로세스 간에 신뢰성 있는 데이터 통신이 가능해집니다.

---
6. 직렬화와 역직렬화에 대해서 설명해주세요.

> 문진수
>
> 직렬화란 데이터 오브젝트를 바이트 스트림으로 변환하여 객체의 상태를 저장하여 디스크에 저장하거나 네트워크를 통해 전송하는 과정을 말합니다. 이를 통해 전송할 데이터의 크기를 줄이고 네트워크를 통해 더 쉽게 전송할 수 있게 됩니다. 

---
7. XSS와 CSRF 공격과 이를 방지하기 위한 방법에 대해서 설명해주세요.

> 문진수
>
> XSS는 공격자가 웹 페이지에 악의적인 스크립트를 삽입하여 사용자 정보를 탈취하거나 악성 행위를 하는 것을 말합니다. 사용자 입력을 검증하지 않아서 주로 발생합니다. XSS 공격은 주로 쿠키 탈취가 많기 때문에 httpOnly 설정을 통해 javaScript로 쿠키 접근을 차단함으로써 XSS 공격을 방지할 수 있습니다.
>
> CSRF는 사용자가 자신의 의지와 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격을 말합니다. 특정 웹사이트에 로그인한 상태에서 사이트간 요청 위조 공격이 삽입된 페이지를 열게 되면 대상이 되는 웹사이트는 위조된 공격이 믿을 수 있는 사용자에게 온 것으로 판단하게 되고 공격에 노출되게 됩니다. 서버에서는 sameSite 설정을 통해 쿠키를 동일한 사이트에서만 사용할 수 있도록 있게 함으로써 CSRF를 방지할 수 있습니다. 또한 CSRF 토큰을 발급하여 요청마다 토큰을 보내게 하여 요청이 악성 사용자로부터 온 것인지 사용자로부터 온 것인지 확인할 수 있습니다.

---

※ 응답 예시

> 네트워크 스터디 공유부탁드립니다.

> 다음 스터디는 자바네요.
