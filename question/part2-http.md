1. Port에 대해서 설명해주세요.
> 강진주
> - 포트 번호는 컴퓨터에서 실행 중인 **프로세스나 서비스**를 구분하기 위해 사용하는 16비트 숫자이다.
> - 포트는 IP 주소와 함께 사용되고 네트워크에서 특정 프로세스를 식별할 수 있는 가상 주소 역할을 한다.
> - 0번 ~ 1023번까지는 **Well-Known Port**로 불리며, HTTP(80), HTTPS(443) 등과 같은 표준 서비스에 할당되어 있다.

> 백명규
> 
> IP 주소만 가지고서는 정확하게 어떤 특정 애플리케이션과 데이터를 주고 받을 지 알 수가 없음.
> 그렇기 때문에 Port라는 서버의 내부에서 프로세스나 서비스를 구분하는 값을 통해서 
> 목적인 애플리케이션을 찾는데 사용하는 식별자 같은 거임.
---
2. Socket에 대해서 설명해주세요.
> 강진주
> 
> 프로그래밍 관점에서, 소켓을 네트워크 인터페이스로 표현하는 경우가 있다. 그러나 이는, 네트워크 연결에 필요한 API를 추상화하여 쉽게 제공하는 것에서 기인한 것이다.
> Linux/Unix 계열의 운영체제에서는 소켓은 파일로 관리되며, 네트워킹에 필요한 정보를 읽고 쓰는 파일 디스크립터가 할당되어 관리된다.
> 하나의 프로세스에서 열 수 있는 파일(파일 디스크립터) 개수는 시스템 변수로 제한된다. ⇒ 즉, 한 프로세스가 열 수 있는 최대 커넥션(소켓) 개수는 해당 시스템 변수로 한정된다.
>
> 
> 네트워크 통신에서 소켓을 구분할 수 있는 구분자는 (Protocol, Source IP, Source Port, Destination IP, Destination Port) 이다.
> 프로토콜에 따라, TCP와 UDP의 소켓 식별 방식이 각각 다르다.
>
>  - **TCP:** 연결 지향이므로 (출발지 IP, 출발지 포트, 목적지 IP, 목적지 포트) 를 통해 소켓을 유일하게 식별한다.
>  - **UDP:** 연결 지향이 아니므로, (목적지 IP, 목적지 포트) 만으로도 수신 측의 소켓을 식별할 수 있다.

> 백명규
> 
> Socket은 전송 계층과 실제 애플리케이션 계층 사이에서 커넥션을 해주는 인터페이스 역할을 해주는 것으로 
> 외부와 통신을 하기 위해 socket이 생성되면 파일 디스크럽터가 반환이 되며 외부와 커넥션이 맺어지면 커넥션의 종류, 
> 시작지 IP, PORT, 도착지 IP, PORT 정보를 얻는다.
> 연결이 돼서 특정 Socket에 요청을 보내야 하면, 생성할 때 얻은 파일 디스크럽터를 통해서 보내는 방식으로 애플리케이션에서는 동작함.

---
3. Socket과 Port의 차이는 무엇인가요?
> 강진주
>
> - **Port**는 네트워크 내의 특정 프로세스를 식별하는 숫자이고
> - **Socket**은 네트워크 통신을 위한 종합적인 개념으로, IP 주소 + 포트 번호의 조합
>   
>   → 즉, 포트는 하나의 주소 역할을 하고, 소켓은 이 포트 정보를 포함한 실제 통신 채널의 개념이다.

> 백명규
> 
> Port는 기기 내의 특정 프로세스 혹은 애플리케이션을 구분하기 위해 부여된 임의의 번호 같은 거임.
> 그리고 Socket은 전송 계층을 애플리케이션 계층에서 컨트롤할 수 있게 해주는 인터페이스인데 
> 본인의 IP와 Port, 상대방의 IP와 Port 커넥션 방식을 통해 구분해서 만들어진 커넥션을 기반으로 정확한 기기의 정확한 프로세스 
> 혹은 애플리케이션 사이에서 패킷을 서로 주고 받게 됨.

---
4. HTTP 프로토콜에 대해서 설명해주세요.
> 강진주
>
> - HTTP(HyperText Transfer Protocol)는 클라이언트(브라우저)와 서버 간에 데이터를 주고받기 위한 **비연결성(Connectionless)**, **무상태(Stateless)** 프로토콜
> - 클라이언트가 요청(Request)을 보내면 서버가 응답(Response)을 보내는 구조로 작동한다.
> - 주로 웹 페이지, 이미지, API 데이터 전송에 사용한다.

> 백명규
> 
> HTTP 프로토콜은 웹에서 클라이언트와 서버가 주고 받는 형태를 모델링한 프로토콜임.
> HTTP는 3.0 버전을 제외하고는 기본적으로 TCP를 기준으로 동작을 하며 
> HTTP 연결을 통해 텍스트 형태로 클라이언트와 서버 사이에서 데이터를 서로 교환을 한다.
> 또한, keep-alive 같은 연결을 유지하는 기능은 없지만 서버 측에서 별도의 상태를 보통은 유지하지 않기 때문에 
> 다음에 요청을 할 때에는 컨텍스트를 설명할 필요가 있다면 쿠키와 같은 걸 통해서 정보를 유지하는 방식을 채택 했다.

---
5. HTTP 프로토콜의 버전 별 차이에 대해서 아는 부분을 설명해주세요.(2.0이하 TCP로 돌아가는 거로 설명 부탁)
> 강진주
> 
> - HTTP 1.0과 1.1의 차이
> - 1.0: 매번 요청마다 연결을 열고 끊어야 했다. (3way, 4way 핸드셰이크 횟수 증가로 계속 패킷 보내고 과대 비용 발생하는 단점. 물론, 일부 커스텀 구현체들 중에서 자체적으로 연결을 유지하도록 만드는 경우도 있었다고 하는데, 해당 기능이 1.1에 공식 규약이 되었다. )
> 
> - 1.1 (keep-alive):
> - 요청이 지속되는 경우, 매번 연결을 맺고 끊는 비용과 시간의 문제를 해결하기 위해 Persistent Connection 즉 Keep-alive 상태를 지원하여, 여러 번 요청이 들어와도 연결을 재사용할 수 있도록 한다.
> - **파이프라이닝(Pipelining)** 지원으로 요청>응답이 동기적으로 처리되지 않는다. 응답이 오지 않아도 요청을 여러 번 보낼 수 있다.
>   - 다만, 응답은 요청한 순서대로 도착해야 해서 **요청 수준의 HOL Blocking** 문제가 발생한다.
>   - 이전 응답이 밀리면 다음에 뒤따라오는 응답도 밀리는 문제가 생긴다.
> - HTTP/2 와 이전 버전의 차이
>   - **멀티플렉싱(Multiplexing)** 지원: 하나의 TCP 연결로 여러 요청과 응답을 동시에 처리할 수 있다. 이는 각 요청에 대한 하나의 논리적인 단위 스트림을 만들고, 스트림 내부에 전달되는 데이터를 헤더 프레임과 데이터 프레임으로 나눠서 병렬 처리가 가능하도록 만들었기 때문이다.
>    - 또한, 허프만 코드를 사용한 헤더 압축(HPACK)으로 데이터 전송 효율이 향상 되었다.
>    - 그러나, TCP 기반이어서 TCP 가 가지는 한계도 가질 수 밖에 없다.
>    - 패킷 손실 시 TCP 수준에서의 HOL Blocking 문제가 여전히 존재한다. 
>    - 요청 수준의 HOL Blocking은 해결되었으나 TCP 기반이라는 한계로 근본적인 문제 해결이 불가능
>    - 이런 흐름을 타파하고자 구글에서는 TCP 를 벗어나 UDP를 활용한 QUIC 프로토콜을 만들었다.

> 백명규
> 
> HTTP 프로토콜에서 0.9버전은 정말 기본적인 내용만 있는 것이었음.
> HTTP 1.0으로 넘어가면서 content-type 헤더가 생겨서 꼭 HTML이 아니어도 보낼 수 있게 됨. 
> 상태 코드, 여러 메서드들도 이 때 추가된 걸로 앎.
> HTTP 1.1이 생기면서 넘어가는 건 keep-alive라는 TCP 연결을 다시 재활용할 수 있는 시간과 횟수를 걸어서 지속적 연결이 가능하게 됐음.
> 매 요청마다 3-way handshake하는 과정이 사라져 조금 더 성능이 좋아짐.
> HTTP 2.0이 생기면서 데이터 전송이 text에서 binary frame으로 인코딩 방식을 바꾸었음.
> 또한, Stream과 multiplexing이라는 전송 개념이 등장함. 연결을 유지한 상태로 병렬적으로 데이터를 전송해도 자체적으로 메시지 순서 정보를 식별하는 게 있어서 애플리케이션 계층의 HOL Blocking 문제를 없앤 걸로 앎. 대신 전송 계층에는 남아있음.

---
6. QUIC 프로토콜에 대해서 설명해주세요.
> 강진주
> 
> - QUIC은 UDP 기반의 새로운 프로토콜으로 HTTP/3의 기반이 된다.
> - **QUIC은 기존의 TCP 한계를 뛰어넘으면서 +** 그동안 UDP의 보안이 부족하다는 단점을 채운 새로운 프로토콜이다.
> - **특징**
>    - **더 빠른 연결 수립이 가능하다. 거의** 0-RTT 핸드셰이크로 초기 연결 속도나 불필요한 핸드셰이크 과정이 생략되었다.
>    - **요청 수준 및 TCP 수준의 HOL Blocking 을 모두 방지한다.**
>    - 보안 계층을 추가하여 보안성을 보장한다. 특히, 기존에 자주 쓰이던 TLS 1.2 버전이 아니라 TLS 1.3이 기본으로 내장되어서 더 짧은 핸드셰이크와 보안 두 가지를 모두 잡았다.

> 백명규
> 
> QUIC 프로토콜은 HTTP 3 버전에 사용이 되는 프로토콜로 TCP 프로토콜 자체의 데이터 순서를 보장한다는 특성 때문에 앞에 큰 파일이 와서
> 뒷 순서가 밀렸을 때 발생하는 HOL Blocking 문제를 근본적으로 해결하기 위해 도입된 프로토콜임.
> 기본적인 아이디어는 UDP 프로토콜을 사용하되 위에 QUIC 프로토콜과 TLS 암호화를 얹어서 UDP에서 부족한 기능들을 보완한 형태로
> 덕분에 HandShake 과정에 TLS까지 한번에 교환을 해서 빨라졌고, 다른 지연으로 인해 막히는 것 관계없이 데이터를 보낼 수 있게 되어 HOL Blocking 문제가 해결이 됨.

---
7. HOL Blocking에 대해서 설명해주세요.
> 강진주
>
> - **HOL(Head-of-Line) Blocking**은 네트워크 큐의 선두 데이터가 지연되면, 뒤따르는 데이터도 지연되는 현상
> - **HTTP/1.1 에서 요청 수준의 HOL Blocking**
>    - 요청이 순차적으로 처리되어, 하나의 요청이 지연되면 이후 요청도 지연된다.
> - **TCP 수준의 HOL Blocking (HTTP/2)**
>    - TCP는 데이터의 순서를 보장하기 위해 패킷이 손실되면 **손실된 패킷을 재전송**하고, 해당 패킷이 도착할 때까지 **뒤의 모든 패킷 처리를 중단한다.**
>    - 패킷 손실 발생 → 재전송 요청 (ACK/NACK) → 손실된 패킷 도착 전까지 **다른 패킷이 보류 상태가 됨**
>    - **큐에 앞(Head)에 해당한 패킷이 지연되면 나머지도 모두 지연되는 상황**

> 백명규
> 
> TCP 프로토콜의 특징은 데이터를 보낼 때 쪼개진 패킷의 순서를 보장하고자 함.
> 그래서 패킷이 serial number 같은 걸 통해 순서대로 전송이 되지 않으면 다시 전송해달라 요청을 보내고 그 뒤 부분은 날리는 방식을 채택함.
> 그러다보니 앞 쪽에 큰 무언가가 전송이 돼서 지연이 되는데 뒤에 작은 뭔가가 날아오면 TCP 특성 때문에 계속 지연이 돼서 브라우저 렌더링이나 그런 게 늦어지는 문제가 발생함.
> 이런 현상을 HOL Blocking이라 하며 전송 계층에서 일어남.

---
8. HTTP 상태 코드 중 200번, 300번, 400번, 500번의 차이는 무엇인가요?
> 강진주
>
> - **2xx (성공):** 요청 성공적으로 처리
>    - `200 OK`: 요청 성공, 서버가 요청한 데이터를 정상적으로 반환
>    - `201 Created`: 요청 성공, 새로운 리소스가 생성됨 (POST 요청 등으로 인해서)
> - **3xx (리다이렉션):** 요청한 리소스를 다른 위치로 이동
>    - `301 Moved Permanently`: 요청한 리소스가 영구적으로 이동
>    - `302 Found`: 임시적으로 다른 URL로 이동
> - **4xx (클라이언트 오류):** 클라이언트의 잘못된 요청이 들어온 경우
>    - `400 Bad Request`: 잘못된 요청 (문법 오류 등)
>    - `401 Unauthorized`: 인증 필요
>    - `403 Forbidden` : 접근 권한 없음 (인증은 성공했지만, 권한 부족)
>    - `404 Not Found`: 요청한 리소스를 찾을 수 없음
> - **5xx (서버 오류):** 서버가 요청을 처리하지 못한 경우
>    - `500 Internal Server Error`: 서버 내부 오류
>    - `502 Bad Gateway`: 게이트웨이 또는 프록시 서버가 잘못된 응답을 받음
> - 보통 무조건 특정 상태 코드를 응답으로 내려줘야한다! 라는 규칙은 없으나 통용되는 상황은 있는듯 하다.. 개발하는 서비스에 맞게 정해서 내려주거나, 관습처럼 많이 사용하는 방식을 따르는 것 같다.
> - 중요한 건 적절한 응답 코드를 통해 상태에 대한 info를 줄 수 있게 하는 것이다.

> 백명규
> 
> - 200번대는 요청이 완성돼었다는 걸 의미하며 OK나 no_content 등은 별도의 메시지를 보내지 않고, 새로운 자원 같은 게 생성되는 created 같은 경우엔 생성된 자원의 식별자 같은 걸 보내줌.
> - 300번대는 리다이렉션되는 경우, 기존 위치에서 다른 곳으로 바뀌거나 하는 경우에 이뤄진다. 거의 잘 안 쓰긴 하지만 바디 본문이 사라지는 지 혹은 검색 엔진에 인덱싱되는 지가 상태 별로 달라서 찾아보고 쓰는 걸 권장한다.
> - 400번대는 클라이언트측 오류로 잘못 입력하거나 하는 경우 Bad Request를 없는 자원이거나 권한이 없는 경우 NOT_FOUND, 해당 경로에 해당 HTTP 메서드가 서버에 처리해줄 서블릿이 없으면 Method not allow 같은 게 뜬다.
> - 500번대는 서버 측에서 오류로 보통 서버에서 자동적으로 복구를 못할 수준의 오류가 났거나 서버 개발자가 잡아서  처리해야 될 예외인데 제대로 처리하지 않은 경우 등에 나온다.
---
